from fastapi import APIRouter, HTTPException, UploadFile, File, Depends, Query
import csv, io, json
from app.database import get_db
from app.auth.deps import get_current_user
from app.finance.categorizer import categorize
from app.utils.events import log_event
import os
from datetime import datetime, timedelta
from dateutil.relativedelta import relativedelta
from typing import Optional


RULES_PATH = os.path.join(os.path.dirname(__file__), "rules.json")

router = APIRouter()

# -------------------------
# HEALTH / HOME
# -------------------------
@router.get("/")
async def finance_home():
    return {"message": "Finance module OK"}


# -------------------------
# TRANSACTIONS (pagination + filters)
# -------------------------
@router.get("/transactions")
async def get_transactions(
    user_id: int = Depends(get_current_user),
    page: int = Query(1, ge=1),
    limit: int = Query(20, le=100),
    type: str | None = None,
    confirmed: bool | None = None,
    search: str | None = None,
):
    offset = (page - 1) * limit

    clauses = ["user_id=%s"]
    params = [user_id]

    if type:
        clauses.append("type=%s")
        params.append(type)

    if confirmed is not None:
        clauses.append("confirmed=%s")
        params.append(int(confirmed))

    if search:
        clauses.append("description LIKE %s")
        params.append(f"%{search}%")

    where = " AND ".join(clauses)

    conn = get_db()
    cur = conn.cursor(dictionary=True)

    cur.execute(
        f"""
        SELECT *
        FROM transactions
        WHERE {where}
        ORDER BY transaction_date DESC, id DESC
        LIMIT %s OFFSET %s
        """,
        (*params, limit, offset),
    )
    rows = cur.fetchall()

    cur.execute(
        f"SELECT COUNT(*) AS total FROM transactions WHERE {where}",
        params,
    )
    total = cur.fetchone()["total"]

    cur.close()
    conn.close()

    return {
        "page": page,
        "limit": limit,
        "total": total,
        "transactions": rows,
    }


# -------------------------
# CSV UPLOAD
# -------------------------
@router.post("/upload-csv")
async def upload_csv(
    file: UploadFile = File(...),
    user_id: int = Depends(get_current_user),
):
    if not file.filename.lower().endswith(".csv"):
        raise HTTPException(400, "Only CSV files allowed")

    content = await file.read()
    reader = csv.DictReader(io.StringIO(content.decode("utf-8-sig")))

    conn = get_db()
    cur = conn.cursor()
    inserted = 0

    for row in reader:
        raw_date = row.get("Transaction Date") or row.get("Date")
        amount_raw = row.get("CAD$") or row.get("Amount")

        if not raw_date or not amount_raw:
            continue

        try:
            txn_date = datetime.strptime(raw_date.strip(), "%m/%d/%Y").date()
            amount = float(amount_raw)
        except Exception:
            continue

        description = " ".join(
            filter(None, [row.get("Description 1"), row.get("Description 2")])
        ).strip()

        txn_type = "expense" if amount < 0 else "income"
        auto_category = categorize(description, amount)

        cur.execute(
            """
            INSERT INTO transactions
            (user_id, transaction_date, description, amount, type, auto_category, raw_data, source_file)
            VALUES (%s,%s,%s,%s,%s,%s,%s,%s)
            """,
            (
                user_id,
                txn_date,
                description,
                amount,
                txn_type,
                auto_category,
                json.dumps(row),
                file.filename,
            ),
        )
        inserted += 1

    conn.commit()
    cur.close()
    conn.close()

    log_event(
        user="sachin",
        module="finance",
        action="finance.csv.import",
        entity_type="csv",
        payload={"file": file.filename, "inserted": inserted},
    )

    return {"file": file.filename, "inserted": inserted}


# -------------------------
# CSV REPLAY (STEP 5)
# -------------------------
@router.post("/replay/{event_id}")
async def replay_csv(
    event_id: int,
    user_id: int = Depends(get_current_user),
):
    conn = get_db()
    cur = conn.cursor(dictionary=True)

    # 1. Fetch event
    cur.execute(
        """
        SELECT payload
        FROM system_events
        WHERE id=%s AND module='finance' AND action='finance.csv.import'
        """,
        (event_id,)
    )
    event = cur.fetchone()
    if not event:
        cur.close()
        conn.close()
        raise HTTPException(status_code=404, detail="Event not found")

    # 2. Payload is stored as JSON STRING â†’ decode it
    try:
        payload = json.loads(event["payload"])
    except Exception:
        cur.close()
        conn.close()
        raise HTTPException(status_code=500, detail="Invalid event payload")

    file = payload.get("file")
    if not file:
        cur.close()
        conn.close()
        raise HTTPException(status_code=400, detail="No file in event payload")

    # 3. Delete previous imports for that file & user
    cur.execute(
        """
        DELETE FROM transactions
        WHERE user_id=%s AND source_file=%s
        """,
        (user_id, file)
    )
    deleted = cur.rowcount

    conn.commit()
    cur.close()
    conn.close()

    return {
        "status": "ready-for-reimport",
        "file": file,
        "deleted_rows": deleted
    }


# -------------------------
# MANUAL CATEGORY OVERRIDE
# -------------------------
@router.patch("/transactions/{tx_id}/category")
async def override_category(
    tx_id: int,
    payload: dict,
    user_id: int = Depends(get_current_user),
):
    category = payload.get("manual_category")
    if not category:
        raise HTTPException(400, "manual_category required")

    conn = get_db()
    cur = conn.cursor()

    cur.execute(
        """
        UPDATE transactions
        SET manual_category=%s, confirmed=1
        WHERE id=%s AND user_id=%s
        """,
        (category, tx_id, user_id),
    )
    conn.commit()

    cur.close()
    conn.close()

    return {
        "status": "updated",
        "transaction_id": tx_id,
        "manual_category": category,
    }


# -------------------------
# SUMMARY (STEP 6 backend)
# -------------------------
@router.get("/summary")
async def finance_summary(
    user_id: int = Depends(get_current_user),
    period: Optional[str] = Query(None, description="Time period: month, year, quarter, all"),
    start_date: Optional[str] = Query(None, description="Start date (YYYY-MM-DD)"),
    end_date: Optional[str] = Query(None, description="End date (YYYY-MM-DD)")
):
    conn = get_db()
    cur = conn.cursor(dictionary=True)

    # Build WHERE clauses
    clauses = ["user_id=%s"]
    params = [user_id]

    # Handle date filtering
    date_filter = ""
    if period and period != "all":
        today = datetime.now()
        if period == "month":
            start = today.replace(day=1)
            end = (start + relativedelta(months=1)) - timedelta(days=1)
        elif period == "quarter":
            quarter = (today.month - 1) // 3
            start = datetime(today.year, quarter * 3 + 1, 1)
            end = (start + relativedelta(months=3)) - timedelta(days=1)
        elif period == "year":
            start = datetime(today.year, 1, 1)
            end = datetime(today.year, 12, 31)
        else:
            start = end = None

        if start and end:
            clauses.append("transaction_date >= %s")
            clauses.append("transaction_date <= %s")
            params.extend([start.date(), end.date()])

    # Handle custom date range
    elif start_date and end_date:
        try:
            start = datetime.strptime(start_date, "%Y-%m-%d").date()
            end = datetime.strptime(end_date, "%Y-%m-%d").date()
            clauses.append("transaction_date >= %s")
            clauses.append("transaction_date <= %s")
            params.extend([start, end])
        except ValueError:
            pass

    where = " AND ".join(clauses)

    # Get ALL transactions for this period
    cur.execute(
        f"""
        SELECT * FROM transactions
        WHERE {where}
        """,
        params
    )
    all_transactions = cur.fetchall()

    # Calculate summary with proper filtering
    income = 0
    expense = 0
    category_totals = {}

    # Keywords to exclude from income/expense totals
    exclude_keywords = [
        "transfer",
        "investment",
        "credit card payment",
        "loan",
        "withdrawal",
        "payment"
    ]

    for tx in all_transactions:
        # Skip transfers and investments
        should_exclude = False
        if tx["type"] and tx["type"].lower() == "transfer":
            should_exclude = True
        else:
            # Check description and category
            desc = (tx.get("description") or "").lower()
            cat = (tx.get("manual_category") or tx.get("auto_category") or "").lower()

            for keyword in exclude_keywords:
                if keyword in desc or keyword in cat:
                    should_exclude = True
                    break

        if should_exclude:
            continue

        # Add to income/expense
        amount = tx["amount"]
        if amount > 0:
            income += amount
        else:
            expense += abs(amount)

        # Add to category totals (expenses only)
        if amount < 0:
            category = tx.get("manual_category") or tx.get("auto_category") or "Uncategorized"
            category_totals[category] = category_totals.get(category, 0) + abs(amount)

    # Format categories
    by_category = [
        {"category": cat, "total": -total}  # Negative for expenses
        for cat, total in sorted(category_totals.items(), key=lambda x: x[1], reverse=True)
    ]

    cur.close()
    conn.close()

    return {
        "income": round(income, 2),
        "expense": round(expense, 2),
        "net": round(income - expense, 2),
        "by_category": by_category,
        "period": period or "all",
        "transaction_count": len(all_transactions)
    }


@router.get("/rules")
async def get_rules(user_id: int = Depends(get_current_user)):
    with open(RULES_PATH) as f:
        return json.load(f)


@router.put("/rules")
async def update_rules(
    payload: dict,
    user_id: int = Depends(get_current_user),
):
    with open(RULES_PATH, "w") as f:
        json.dump(payload, f, indent=2)

    return {"status": "updated"}

@router.get("/export")
async def export_transactions(
    user_id: int = Depends(get_current_user),
    format: str = Query("csv", description="Export format: csv, json"),
    start_date: Optional[str] = Query(None, description="Start date (YYYY-MM-DD)"),
    end_date: Optional[str] = Query(None, description="End date (YYYY-MM-DD)")
):
    conn = get_db()
    cur = conn.cursor(dictionary=True)
    
    # Build WHERE clauses
    clauses = ["user_id=%s"]
    params = [user_id]
    
    if start_date and end_date:
        try:
            start = datetime.strptime(start_date, "%Y-%m-%d").date()
            end = datetime.strptime(end_date, "%Y-%m-%d").date()
            clauses.append("transaction_date >= %s")
            clauses.append("transaction_date <= %s")
            params.extend([start, end])
        except ValueError:
            pass
    
    where = " AND ".join(clauses)
    
    cur.execute(
        f"""
        SELECT 
            transaction_date as date,
            description,
            amount,
            type,
            auto_category,
            manual_category,
            confirmed,
            source_file
        FROM transactions
        WHERE {where}
        ORDER BY transaction_date DESC
        """,
        params
    )
    
    transactions = cur.fetchall()
    cur.close()
    conn.close()
    
    if format == "csv":
        import csv
        import io
        
        output = io.StringIO()
        writer = csv.writer(output)
        
        # Write header
        writer.writerow([
            "Date", "Description", "Amount", "Type", 
            "Auto Category", "Manual Category", "Confirmed", "Source File"
        ])
        
        # Write data
        for tx in transactions:
            writer.writerow([
                tx["date"],
                tx["description"],
                tx["amount"],
                tx["type"],
                tx["auto_category"],
                tx["manual_category"],
                "Yes" if tx["confirmed"] else "No",
                tx["source_file"]
            ])
        
        from fastapi import Response
        return Response(
            content=output.getvalue(),
            media_type="text/csv",
            headers={"Content-Disposition": f"attachment; filename=transactions_{datetime.now().date()}.csv"}
        )
    
    else:  # json
        return {
            "count": len(transactions),
            "transactions": transactions
        }
